
//From core.chi
(fn inc n (+ n 1))
(fn dec n (- n 1))
(fn 1st  i (nth i 0))
(fn 2nd  i (nth i 1))
(fn last i (nth i (dec (len i))))
(fn append  v i (vec (burst v) i))
(fn ex-last i (sect i 0 (dec (len i))))
(fn empty? i (= (len i) 0))
(fn !empty? i (!= (len i) 0))
(fn includes? coll i
  (do find= i (or (burst (map {= find #} coll)))))
(fn key v k
  (if (empty? v) (return N))
  (if (= (1st v) k) (return (2nd v)))
  (recur (sect v 2) k))

//Replace all occurences of `r` with `w` in the string `s`
(fn replace-all s r w ;; out
  (if (empty? s) (return out))
  (recur (sect s) r w
    (str (or out "")
      (if (= (1st s) r) w (1st s)))))

//Scans for first index of item, str, or char `sub` within `coll`, before index `until`
//Accepts optional is-negative boolean to find the next index that is not `sub`
(fn index-of-until
  coll sub until; is-negative; i len
  (if (or (= i until) (< (len coll) (len sub))) (return N))
  (do comp-op= (if is-negative != =)
    (if (comp-op (str sub) (sect coll 0 (len sub)))
      (or i 0i)
      (recur (sect coll) sub until is-negative (inc (or i 0i))))))

//Scans for first index of item, str, or char `sub` within `coll`
(fn index-of
  coll sub
  (index-of-until coll sub (len coll) F))

//Finds the next index of item, str, or char in `finds`, in `coll` as a vec or str
//Returns [the next find; index], with the find as nil if nothing was found
(fn next-index-of
  string finds ;; m win
  (if (empty? finds) (return [win m]))
  (do minimum= (or m (len string))
      find=    (1st finds)
      index=   (index-of-until string find minimum)
    (burst
      (if (and index (< index minimum))
        [minimum= index winner= find]
        [winner= win]))
    (recur string (sect finds) minimum winner)))

//Returns the next index of item, str, or char not in `anti-finds`, in `coll` as a vec or str
(fn next-index-of-not
  string anti-finds ;; i
  (if (empty? string) (return N))
  (do string2= string
    (if (or (burst (map {= (str #) (sect string2 0 (len #))} anti-finds)))
      (recur (sect string) anti-finds (+ (or i 0i) 1i))
      (or i 0i))))

//Replaces contiguous spaces with one space
(fn shrink-space
  in ;; out
  (if (empty? in) (return out))
  (do prev= (last out)
      next= (1st in)
    (recur (sect in) (str (or out "") (if (= prev next \sp) "" next)))))



//Returns instance length
(fn stage1-process
  str-in found path-out num-str
  (case found
    \\   //If a char literal, output its character code
    (do
      lit-len=   (if (includes? ["nl" "sp"] (sect str-in 0 2)) 2 1)
      char-lit=  (sect str-in 0 lit-len)
      char-code= (cast (or (key ["nl" \nl "sp" \sp] char-lit) (1st char-lit)) 0x10)
      (file-a path-out (str "`c" char-code \`))
      lit-len)
    \"   //If a string, output to the string file, and substitute for `n`
    (do
      str-len= (index-of str-in \")
      string=  (sect str-in 0 str-len)
      (file-a path-out (str \` num-str \`))
      (file-a (str path-out "s") string)
      (file-a (str path-out "sl") (cast (+ 0w str-len) 0x0C))
      (inc str-len))
    "//"  //If a single-line comment, skip until after a newline
    (inc (index-of str-in \nl))
    "/*"  //If a multi-line comment, skip until "*/"
    (+ (index-of str-in "*/") 2)
    \;    //If a semicolon, output a space
    (do (file-a path-out \sp) 0)
    \,    //If a comma, skip until not whitespace
    (next-index-of-not str-in [\sp \; \, \nl])
    \[    //If a vector open, output `(vec `
    (do (file-a path-out "(vec ") 0)
    \]    //If a vector close, output a close parenthesis
    (do (file-a path-out \)) 0)))

//Finds an instance of...
//  a char literal, string, multi-line or single-line comment,
//  comma, semicolon, vector start/end, newline
(fn stage1-seek
  path-in path-out offset num-str
  (print offset \nl)
  (do chunk-size= 128
      str-in=     (str (file-r path-in offset chunk-size))
      next-index= (next-index-of str-in [\" "//" "/*" \\ \; \, \[ \]])
      found=      (1st next-index)
      at=         (or (2nd next-index) chunk-size)
    (if (empty? str-in) (return))
    //Output up until the instance, or do transparent pass-through
    (if (!= at 0)
      (file-a path-out
        //(sect str-in 0 at)))
        (replace-all (sect str-in 0 at) \nl \sp)))
    (if found
      (do
        //Process the instance
        offset2=      (+ offset at (len found))
        str-in=       (str (file-r path-in offset2 chunk-size))
        instance-len= (stage1-process str-in found path-out num-str)
        new-num-str=  (if (= found \") (inc num-str) num-str)
        //Recur onward
        (recur path-in path-out (+ offset2 instance-len) new-num-str))
      //Recur onward
      (recur path-in path-out (+ offset chunk-size) num-str))))



(do path-in=  "init.chi"
    path-out= "init."
  //Empty all cache files
  (map {file-d (str path-out #) "" 0} ["0" "0s" "0sl"])
  //Begin stage 1
  (stage1-seek path-in (str path-out "0") 0i 0i)
  //Finished
  (print "Compilation of `" path-in "` complete in " (ms-now) "ms" \nl))