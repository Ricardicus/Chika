(fn ! x (if x F T))

(fn inc n (+ n 1))
(fn dec n (- n 1))
(fn even? n (= (mod n 2) 0))
(fn odd? n (! (even? n)))
(fn pos? n (<= 0 n))
(fn neg? n (< n 0))
(fn neg n (- 0i n))
(fn min a b (if (< a b) a b))
(fn abs n (if (pos? n) n (neg n)))

(fn 1st  i (nth i 0))
(fn 2nd  i (nth i 1))
(fn last i (nth i (dec (len i))))
(fn prepend v i (vec i (burst v)))
(fn append  v i (vec (burst v) i))
(fn concat v1 v2 (vec (burst v1) (burst v2)))
(fn ex-last i (sect i 0 (dec (len i))))
(fn empty? i (= (len i) 0))
(fn !empty? i (!= (len i) 0))
(fn includes? coll i
  (do find= i (or (burst (map {= find #} coll)))))

(fn every? vec pred
  (if (= (len vec) 0)
    T
    (if (pred (1st vec))
      (recur (sect vec) pred)
      F)))

(fn some vec pred
  (if (= (len vec) 0)
    N
    (if (pred (1st vec))
      (1st vec)
      (recur (sect vec) pred))))

(fn filter v pred; filtered
  (if (= (len v) 0)
    filtered
    (do f= (1st v)
      (recur (sect v) pred
        (if (pred f)
          (append filtered f)
          filtered)))))

//Scans for first index of vec, str, or char `sub` within `coll`, else nil
//e.g. (index-of "hello" "ll") => 2
(fn index-of
  coll sub; i len
  (if (!empty? coll)
    (if (= (str sub) (sect coll 0 (len sub)))
      i
      (recur (sect coll) sub (inc (or i 0i))))))

//e.g. (zip-select [F T F] [\a \b \c]) => \b
(fn zip-select select from
  (if (!empty? select)
    (if (1st select)
      (1st from)
      (recur (sect select) (sect from)))
    N))

//e.g. (range 0 10 2) => [0 2 4 6 8]
//e.g. (range 10 0 -2i) => [10 8 6 4 2]
(fn range from to step v
  (if (!= from to)
    (recur (+ from step) to step
      (append v from))
    v))

//Returns item after `k` in vector/string `v`
(fn key v k
  (if (empty? v) (return N))
  (if (= (1st v) k) (return (2nd v)))
  (recur (sect v 2) k))

//e.g. (str->int "123") => 123i
(fn n*10^p-1 n p
  (if (== p 1) n
    (* n (pow 10i (- p 1)))))
(fn str->int s
  (reduce +
    (map n*10^p-1
      (map {cast (- # 48) 18} (vec (burst s)))
      (range (len s) 0 -1i))))
